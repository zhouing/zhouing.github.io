<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhouTing&#39;s Blog</title>
  
  <subtitle>一个回收自己生活的垃圾站。。。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-21T03:06:29.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zhou Ting</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>部分JS API理解</title>
    <link href="http://example.com/2021/03/21/JS-API/"/>
    <id>http://example.com/2021/03/21/JS-API/</id>
    <published>2021-03-21T03:06:29.000Z</published>
    <updated>2021-03-21T03:06:29.000Z</updated>
    
    <content type="html"><![CDATA[        <h3 id="react兄弟组件通信"   >          <a href="#react兄弟组件通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#react兄弟组件通信" class="headerlink" title="react兄弟组件通信"></a>react兄弟组件通信</h3>      <p>1、找相同的父组件，既可以用props传递也可以使用context传递<br>2、使用全局机制实现通信，例redux<br>3、发布订阅模式</p>        <h3 id="发布-订阅模式"   >          <a href="#发布-订阅模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3>      <p>组件间通信引入一个类的实例，并使用单例模式（只有一个实例）实现<br>定义发布对象</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class SingleonPush &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.listenList &#x3D; &#123;&#125;</span><br><span class="line">        this.instance &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    static getInstance: () &#x3D;&gt; &#123;</span><br><span class="line">        if (!this.instance) &#123;</span><br><span class="line">            this.instance &#x3D; new SingleonPush()</span><br><span class="line">        &#125;</span><br><span class="line">        return this.instance</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 订阅者添加订阅事件</span><br><span class="line">    addListen: (key, fn) &#x3D;&gt; &#123;</span><br><span class="line">        if(!this.listenList[key]) &#123;</span><br><span class="line">            this.listenList[key] &#x3D; []</span><br><span class="line">        &#125;</span><br><span class="line">        this.listensList[key].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 发布者发布消息，执行订阅者订阅的事件</span><br><span class="line">    trigger: () &#123;</span><br><span class="line">        const key &#x3D; Array.from(arguments).shift()</span><br><span class="line">        const fns &#x3D; this.listenList[key]</span><br><span class="line">        (fns || []).forEach(fn &#x3D;&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 移除订阅事件</span><br><span class="line">    removeListen: (key, fn) &#x3D;&gt; &#123;</span><br><span class="line">        const fns &#x3D; this.listenList[key]</span><br><span class="line">        if(!fns || fns?.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fn) &#123;</span><br><span class="line">            this.listenList[key] &#x3D; []</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fns.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">                if(item &#x3D;&#x3D;&#x3D; fn) &#123;</span><br><span class="line">                   fns.splice(index, 1) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default SingleonPush.getInstance()</span><br></pre></td></tr></table></div></figure><p>订阅者订阅一个事件<br>订阅者：订阅一个或多个信道消息的对象</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import SingleonPush from &#39;..&#x2F;SingleonPush&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">SingleonPush.addlisten(&#39;back&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;订阅back&#39;)</span><br><span class="line">    SingleonPush.removeListen(&#39;back&#39;, handleExist)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure><p>发布者发布一个back消息<br>发布者： 消息的发布者，往信道中投递消息的对象</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import SingleonPush from &#39;..&#x2F;SingleonPush&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">SingleonPush.trigger(&#39;back&#39;)</span><br></pre></td></tr></table></div></figure>        <h3 id="IntersectionObserver"   >          <a href="#IntersectionObserver" class="heading-link"><i class="fas fa-link"></i></a><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3>      <p>异步观察目标元素与其祖先元素或根元素交叉状态的方法（即观察目标元素是否可见）<br><code>const io = new IntersectionObserver(callback, option)</code><br>当元素可见比例超过指定阙值后，会调用callback，callback接收两个参数：<br>entries: 一个IntersectionObserverEntry对象的数组<br>observer: IntersectionObserver的实例<br>options配置选项：<br>root: 监听对象的祖先Element对象，默认为文档视口，<br>rootMargin： 一个在计算交叉值时添加至根的边界盒中的一组偏移量，值类似margin的值，默认没有margin<br>threshold： 规定了一个监听目标和边界盒交叉的比例值，可以是一个0.0-1.0的具体数字或数组，默认为0.0，意味着目标元素与边界的比例大于0.0时，目标元素被视为看见，如果设置为0.5则是在比例为50%的时候才视为看见，才会调用callback。<br>IntersectionObserverEntry对象属性：<br>time: 可见性发生变化的时间<br>target： 被观察的目标元素<br>rootBounds： 根元素的矩形区域信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null<br>boundingClientRect：目标元素的矩形区域的信息<br>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息<br>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0<br>isIntersecting: Boolean,如果为true，表示变换是从非交叉状态到交叉状态，反之为false</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现懒加载</span><br><span class="line">const oberver &#x3D; new IntersectionObserver((entries, ob) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(entries)</span><br><span class="line">    entries.forEach(ioEntry &#x3D;&gt; &#123;</span><br><span class="line">        const container &#x3D; ioEntry.target</span><br><span class="line">        const content &#x3D; container.querySelector(&#39;template&#39;).content</span><br><span class="line">        container.appendChild(content)</span><br><span class="line">        ob.unobserve(container)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">Array.from(document.querySelectorAll(&#39;lazy-load&#39;)).forEach(elm &#x3D;&gt; &#123;</span><br><span class="line">    observe.observe(elm)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure><p>注： IntersectionObserver是异步的，实现采用了requestIdleCallback()，所以只有等线程空闲下来才会执行，优先级非常低</p>        <h3 id="MutationObserver-监视DOM树所做的更改"   >          <a href="#MutationObserver-监视DOM树所做的更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#MutationObserver-监视DOM树所做的更改" class="headerlink" title="MutationObserver: 监视DOM树所做的更改"></a>MutationObserver: 监视DOM树所做的更改</h3>      <p>属于微任务，异步的，为了防止Dom频繁变动占用js执行栈造成页面卡顿<br>会在DOM发生变化时被调用<br>实例方法：<br>disconnect(): 停止实例继续接收的通知<br>observer(): 通过回调函数开始接收通知<br>takeRecords(): 从通知队列中删除所有待处理的通知，并返回到MutationRecord对象的新Array中</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const dom &#x3D; document.getElementById(&#39;dom&#39;)</span><br><span class="line">const callback &#x3D; (mutationList, observe) &#x3D;&gt; &#123;</span><br><span class="line">    for(let mutation of mutationList) &#123;</span><br><span class="line">        &#x2F;&#x2F; mutation 为MutationRecord对象，MutationRecord对象是我们每修改一个就会在数组里面追加一个</span><br><span class="line">        if(mutation.type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span><br><span class="line">            console.log(&#39;child node has changed&#39;)</span><br><span class="line">        &#125; else if (mutation.type &#x3D;&#x3D;&#x3D; &#39;attributes&#39;) &#123;</span><br><span class="line">            console.log(&#96;ths mutationAttributes name is $&#123;mutation.attributeName&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const observer &#x3D; new MutationObserver(callback)</span><br><span class="line">&#x2F;&#x2F; 调用observe()时,childList, attributes或characterData中至少有一个为true，否则会报错</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">    attributes: true, &#x2F;&#x2F; 监听元素属性值得变更，如果为false，并且配置了attributeFilter或attributeOldValue为true，则会报错</span><br><span class="line">    childList: true, &#x2F;&#x2F; 设为true以监听目标节点（如果subtree为true，则包含子孙节点）添加或删除子节点，默认为false</span><br><span class="line">    subtree: true, &#x2F;&#x2F; 设为true以将监听范围扩展到目标节点下的所有节点</span><br><span class="line">    &#x2F;&#x2F; attributeFilter: Array, 指定要监视的属性名称，例如[&#39;calss&#39;, &#39;src&#39;]</span><br><span class="line">    &#x2F;&#x2F; attributeOldValue: Boolean, 当属性改动是，设置为true可以记录任何改动属性的上一个值</span><br><span class="line">    &#x2F;&#x2F; characterData: Boolean, 设为true以监听目标节点或子节点中包含的字符数据的变化, 如果为false，而characterDataOldValue为true，则会报错</span><br><span class="line">    &#x2F;&#x2F; characterDataOldValue: Boolean,设为true以在文本更改时记录节点文本的先前值</span><br><span class="line">&#125;</span><br><span class="line">observer.observer(dom, config)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; when it&#39;s time to stop observe</span><br><span class="line">&#x2F;&#x2F; handle any still-pending mutations</span><br><span class="line"></span><br><span class="line">const mutations &#x3D; observer.takeRecords() &#x2F;&#x2F; 同步的</span><br><span class="line">if(mutations) &#123;</span><br><span class="line">    callback(mutations)</span><br><span class="line">&#125;</span><br><span class="line">observer.disconnect()</span><br></pre></td></tr></table></div></figure>        <h3 id="window-requestAnimationFrame-fn"   >          <a href="#window-requestAnimationFrame-fn" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-requestAnimationFrame-fn" class="headerlink" title="window.requestAnimationFrame(fn)"></a>window.requestAnimationFrame(fn)</h3>      <p>希望执行一个动画，并且要求浏览器在下一次重绘之前调用指定的回调函数更新动画<br>回调函数fn会在浏览器下一次重绘之前执行</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const animateBox &#x3D; document.getElementById(&#39;animate-box&#39;)</span><br><span class="line">const requestAnimationFrame &#x3D; window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;</span><br><span class="line">const cancelAnimationFrame &#x3D; window.cancelAnimationFrame || window.mozCancelAnimationFrame;</span><br><span class="line">let start</span><br><span class="line">let AnimationFrameID</span><br><span class="line">function step(timestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F; timestamp为时间戳</span><br><span class="line">    if(start &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        start &#x3D; timestamp</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    const elapsed &#x3D; timestamp - start</span><br><span class="line">    animateBox.style.transform &#x3D; &#96;translateX($&#123;Math.min(0.1 * elapsed, 200)&#125;px)&#96;</span><br><span class="line">    if(elapsed &lt; 2000) &#123;</span><br><span class="line">        AnimationFrameID &#x3D; requestAnimationFrame(step)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cancelAnimationFrame(AnimationFrameID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AnimationFrameID &#x3D; requestAnimationFrame(step)</span><br></pre></td></tr></table></div></figure>        <h3 id="window-requestIdleCallback-启用在浏览器空闲期对任务进行调度"   >          <a href="#window-requestIdleCallback-启用在浏览器空闲期对任务进行调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-requestIdleCallback-启用在浏览器空闲期对任务进行调度" class="headerlink" title="window.requestIdleCallback(): 启用在浏览器空闲期对任务进行调度"></a>window.requestIdleCallback(): 启用在浏览器空闲期对任务进行调度</h3>      <p><code>window.requestIdleCallback(callback[, options])</code><br>options: {timeout}<br>强烈建议使用timeout选项进行必要的工作，否则可能会在触发回调之前经过几秒钟</p>        <h3 id="window-dispatchEvent-used-to-trigger-an-event"   >          <a href="#window-dispatchEvent-used-to-trigger-an-event" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-dispatchEvent-used-to-trigger-an-event" class="headerlink" title="window.dispatchEvent(): used to trigger an event"></a>window.dispatchEvent(): used to trigger an event</h3>      <p>向一个指定的事件目标派发一个事件</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; const event &#x3D; new Event(&#39;build&#39;)</span><br><span class="line">&#x2F;&#x2F; 如果需要添加数据可以使用CustomEvent()</span><br><span class="line">const event &#x3D; new CustomEvent(&#39;build&#39;, &#123; detail: &#39;this is detail&#39; &#125;)</span><br><span class="line"></span><br><span class="line">elm.addEventListener(&#39;build&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;This is detail: $&#123;e.detail&#125;&#96;)</span><br><span class="line">&#125;, false)</span><br><span class="line"></span><br><span class="line">elm.dispatchEvent(&#39;build&#39;)</span><br></pre></td></tr></table></div></figure><p>为了兼容性，可以使用旧的API</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const event &#x3D; document.createEvent(&#39;Event&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;event.initEvent(type, bubbles, cancelable);</span><br><span class="line">event.initEvent(&#39;build&#39;, true, true)</span><br><span class="line">elm.addEventListener(&#39;build&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(e.target)</span><br><span class="line">&#125;, false)</span><br><span class="line">elm.dispatchEvent(event)</span><br></pre></td></tr></table></div></figure><p><code>cancelled = !target.dispatchEvent(event)</code><br>返回值：如果该事件是可取消的且至少一个该事件的事件处理方法调用了<code>Event.preventDefault()</code>,则返回<code>false</code>，反之返回<code>true</code><br>注：与浏览器原生事件不同，原生事件是由DOM派发，并通过<code>event loop</code>异步调用事件处理函数；<code>dispatchEvent()</code>是同步调用事件处理程序</p>        <h3 id="window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）"   >          <a href="#window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）" class="headerlink" title="window.setImmediate(): 在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）"></a>window.setImmediate(): 在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）</h3>      <p>可以用setTimeout(fn, 0)替代</p>        <h3 id="MessageChannel"   >          <a href="#MessageChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#MessageChannel" class="headerlink" title="MessageChannel()"></a>MessageChannel()</h3>      <p>创建一个新的消息通道，并通过它的两个MessagePort属性传递消息，在Web Worker中可用<br><code>const channel = new MessageChannel()</code><br>channel实例有两个属性：port1， port2<br>两个端口可以让你从一个端口发生消息，并在消息到达后再另一个端口监听<br>MessagePort上的方法：<br>postMessage: 发送消息，会自动序列化并且是深拷贝<br><code>port.postMessage(message, [transferList])</code><br>message可以是任何基本类型<br>start：开始发送该端口的消息队列（只有当使用<code>EventTarget.addEventListener</code>的时候才需要调用，使用<code>onmessage</code>时是默认开始的）<br>close: 断开接口连接<br>事件回调：继承自EventTarget的事件回调<br>onmessage: 是一个EventListener，当类型为 message 的 MessageEvent 在该端口触发时，会调用<br>onmessageerror: 类型为 MessageError 的 MessageEvent 被触发时，会调用，这意味着，端口收到了一条无法被反序列化的消息<br>事件： message、messageerror</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new MessageChannel()</span><br><span class="line">const output &#x3D; document.querySelector(&#39;.output&#39;)</span><br><span class="line">const iframe &#x3D; document.querySelector(&#39;iframe)</span><br><span class="line"></span><br><span class="line">iframe.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    channel.port1.onmessage &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">        output.innerHTML &#x3D; e.data</span><br><span class="line">    &#125;</span><br><span class="line">    iframe.contentWindow.postMessage(&#39;This is a message from home page&#39;, &#39;*&#39;, [channel.port2])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure><p>使用MessageChannel实现对象深拷贝</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const DeepClone &#x3D; (obj) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用Promise是为了方便拿到数据，因为下面是异步的</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        const channel &#x3D; new MessageChannel()</span><br><span class="line">        channel.port2.onmessage &#x3D; (e) &#x3D;&gt; resolve(e)</span><br><span class="line">        channel.port1.postMessage(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const originObj &#x3D; &#123; id: 1, info: &#123; name: &#39;jack&#39;&#125;&#125;</span><br><span class="line">DeepClone(originObj).then(res &#x3D;&gt; &#123;</span><br><span class="line">    const obj1 &#x3D; res</span><br><span class="line">    obj1.info.name &#x3D; &#39;mark&#39;</span><br><span class="line">    console.log(obj1, originObj) &#x2F;&#x2F; originObj不会改变</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>        <h3 id="window-postMessage-：可以安全地实现跨源通信"   >          <a href="#window-postMessage-：可以安全地实现跨源通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-postMessage-：可以安全地实现跨源通信" class="headerlink" title="window.postMessage()：可以安全地实现跨源通信"></a>window.postMessage()：可以安全地实现跨源通信</h3>      <p>一般两个不同的页面只有同源(同协议，同端口，同域)才能互通消息，而window.postMessage提供了一种受控机制来规避这个限制<br><code>otherWindow.postMessage(message, targetOrigin[, transferList])</code><br>messgage: 自动序列化，深拷贝<br>message中的属性：<br>    data：传递过来的对象<br>    origin：消息发送方窗口的origin<br>    source：对发送消息窗口对象的引用，可以在两个窗口直接建立双向通信<br>targetOrigin：用来指定那些窗口能接收到消息事件。值可以是字符串’<em>‘(无限制)或一个URL。注：如果不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点<br>transferList：是一串和message同时传递的Transferable对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权<br>注安全问题： 如果需要从其他网站接收message，要始终使用origin和source属性来验证发件人的身份；在发送message时，请始终指定精确的目标origin，而不是’</em>‘</p>        <h3 id="FileReader-允许web应用程序异步读取存储在计算机上的文件的内容"   >          <a href="#FileReader-允许web应用程序异步读取存储在计算机上的文件的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileReader-允许web应用程序异步读取存储在计算机上的文件的内容" class="headerlink" title="FileReader: 允许web应用程序异步读取存储在计算机上的文件的内容"></a>FileReader: 允许web应用程序异步读取存储在计算机上的文件的内容</h3>      <p>使用File或Blob对象指定读取的文件或数据；File对象可以来自：Input元素选择文件返回的FileList对象；拖放操作生成的DataTransfer对象；来自HTMLCanvasElement上执行mozGetAsFile()方法后返回的结果<br><code>const fileReader = new FileReader()</code><br>属性：<br>error： 读取文件时发生的错误<br>readyState： 0(还没加载任何数据) | 1(数据正在被加载) | 2(已完成全部数据读取请求)<br>result： 文件的内容，只有在读取操作完成后才有效，数据格式根据使用那个方法来启动读取操作决定<br>事件处理：<br>onabort：读取操作被中断时触发，readyState为2<br>onerror<br>onload： 读取操作完成时触发<br>onloadstart<br>onloadend<br>onprogress<br>注： 这些事件都可以通过addEventListener使用<br>方法：<br>abort： 中止读取操作<br>readAsArrayBuffer： 开始读取指定的Blob中的内容，完成后result中保存的将是读取文件的ArrayBuffer数据对象<br>readAsBinaryString: 非标准<br>readAsDataURL<br>readAsText</p>        <h4 id="ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区"   >          <a href="#ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区" class="headerlink" title="ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区"></a>ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区</h4>      <p>是一个字节数组<br>不能直接操作ArrayBuffer的内容，需要通过类型数组对象(TypedArray)或DataView对象来操作<br><code>const buffer = new ArrayBuffer(length)</code><br>length不能大于Number.MAX_SAFE_INTEGER(2**53)或为负数<br>实例属性： byteLength<br>实例方法： slice()</p>        <h5 id="TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图"   >          <a href="#TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图" class="heading-link"><i class="fas fa-link"></i></a><a href="#TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图" class="headerlink" title="TypedArray: 描述了一个底层的二进制数据缓冲的一个类数组视图"></a>TypedArray: 描述了一个底层的二进制数据缓冲的一个类数组视图</h5>      <p>所有TypedArray：<br>Int8Array(), Unit8Array(), Uint8ClampedArray(), Int16Array(), Unit16Array(), Int32Array(), Unit32Array(), Float32Array(), Float64Array()<br>参数：length | TypedArray | object | buffer [, byteOffset [, length]]</p>        <h5 id="DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口"   >          <a href="#DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口" class="headerlink" title="DataView： 一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口"></a>DataView： 一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口</h5>      <p><code>const view = new DataView(buffer[, byteOffset, byteLength])</code><br>可以进行读写操作，例如： view.setInt8(), view.getInt8</p>]]></content>
    
    
    <summary type="html">主要是一些我常看到但不太熟熟悉的API，这里只是简单认识，未深入。</summary>
    
    
    
    <category term="IT" scheme="http://example.com/categories/IT/"/>
    
    <category term="WEB" scheme="http://example.com/categories/IT/WEB/"/>
    
    <category term="Javascript" scheme="http://example.com/categories/IT/WEB/Javascript/"/>
    
    
    <category term="-前端 -javascript" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF-javascript/"/>
    
  </entry>
  
  <entry>
    <title>长安行</title>
    <link href="http://example.com/2021/01/07/xi&#39;an/"/>
    <id>http://example.com/2021/01/07/xi&#39;an/</id>
    <published>2021-01-07T13:54:36.000Z</published>
    <updated>2021-01-07T13:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>不入长安城，不知未央名。汉唐不尽是，芙蓉满园春。西安作为十三朝古都，中国七大古都之一，一直是我向往的地方之一。去到那边让我领略到了中国五千年的历史，给我留下了深刻的印象</p>        <h2 id="day1：入长安"   >          <a href="#day1：入长安" class="heading-link"><i class="fas fa-link"></i></a><a href="#day1：入长安" class="headerlink" title="day1：入长安"></a>day1：入长安</h2>      <p>到机场后坐机场大巴到市区酒店（咸阳机场离西安市区挺远的，目前还没有地铁直达，只能坐机场大巴，三十分钟一班，需要身份证购买）。我们前面两天定的是丽晶酒店，在钟楼附近，去哪里都还挺方便的，酒店还可以吧（注意不要去他家酒店的一日游团，比网上贵很多，所以线下的一日游两日游都比网上贵，推荐网上订）。中午办理入住后就去吃饭了，当然第一顿肯定是凉皮肉夹馍油泼面啦，当时比较饿就随便找了个店，整体还行。吃完饭就开始打卡啦。首先是鼓楼，西安鼓楼是现存中国最大鼓楼，位于西安城内西大街北院门南端，东与钟楼相望。听导游说跨年的钟声就是钟楼的钟声，但是现在钟没有在钟楼里，好像在博物馆还是哪。但是很多人都推荐不要上去，我也觉得没必要上去，远远看一下就行然后去鼓楼旁边的回民街，看了一些买纪念品什么的店后就去了城墙。门票是54，我们是从东大门上去的，然后一路走到了南门，不想走上面可以租自行车骑，城墙还是可以上去看看的。晚上我们回到回民街吃，去打卡了天天向上节目中的米家羊肉泡馍，自己手撕泡馍，这个真的考验耐心。味道一般，我不是很喜欢。给个建议最好不要去回民街吃东西，卫生不好，吃的也不好吃，重复的也多，可以去永兴坊和xxx。回民街避雷：烤羊蹄（真的不好吃，和猪蹄完全不一样），门口第一家老孙家的肉夹馍也不好吃，晚上你可能会发现很多人排队，那可能是托）<br><img src="/images/post/xi'an-3.jpg"></p>        <h2 id="day2：兵马俑-华清池"   >          <a href="#day2：兵马俑-华清池" class="heading-link"><i class="fas fa-link"></i></a><a href="#day2：兵马俑-华清池" class="headerlink" title="day2：兵马俑+华清池"></a>day2：兵马俑+华清池</h2>      <p>由于距离比较远，我们报了一日游团，在马蜂窝app上报的两个人360（比较之下这个算比较便宜的）。早上在三环以内是可以接的，早上七点半左右出发，包含早餐（德克士的汉堡）。提供耳机可以听导游解说，这两个地方都比较偏解说所以解说很必要，导游说如果自己看这两个地方就是几个坑😂。从西安到华清池大概如此坐车要一个多小时，我们选择一日游的原因除了听解说还有就是交通，如果自由行又没有开车交通会很不方便。中途导游会介绍华清池里面有一个剧《西安事变》和兵马俑也有一个剧《复活的军团》，两个一起380，我们只看了复活的军团，只一个的话是218，其实我一开始以为是中途强制消费，后面其实你如果实在不想看也可以不看，西安事变是一个小时，复活的军团是一个小时零十分钟，不看的就在外面等。我觉得复活的军团还是不错，挺震撼的。华清池是一日游的导游解说的，到了兵马俑就必须是馆里的解说统一解说了，我觉得我们兵马俑那个解说前面解说还行，后面不知道是敢时间还是干嘛到了最后二号坑的时候都没怎么说就开始给我们讲蓝田玉，然后讲着讲着就带我们去了卖蓝田玉的地方了，然后开始推销…就这一点我们不喜欢，其他都还好，当然你也可以你买，不是强制的。建议如果是自由行的小伙伴们记住在兵马俑中不要走回头路，观看顺序是先一号坑、三号坑、四号坑（真的就是一个坑，里面什么都没有，也可以选择不看）、最后是二号坑，这是导游给我们介绍的顺序。回程后我们在永兴坊下的车，永兴坊的小吃总体比回民街好吃一点，正规干净很多，那边还有皮影戏表演。<br><img src="/images/post/xi'an-2.jpg"></p>        <h2 id="day3：大唐不夜城跨年"   >          <a href="#day3：大唐不夜城跨年" class="heading-link"><i class="fas fa-link"></i></a><a href="#day3：大唐不夜城跨年" class="headerlink" title="day3：大唐不夜城跨年"></a>day3：大唐不夜城跨年</h2>      <p>第三天我们选择休息一下并且为了跨年换了个酒店。上午休息然后去酒店，我们选了离大唐不夜城很近的星程酒店，酒店一般吧，感觉偏贵了一点点。比较遗憾的是我们是准备下午去历史博物馆的，然后由于预约晚了没有预约到，我们就只能去大唐芙蓉园玩了一段时间，我们去时候是不要门票的，不过听说以前大唐芙蓉园是要门票的，然后要门票的话如果超过80就不值得进去了，不过如果想感受唐风唐韵的可以进去逛逛。我们没有去看大雁塔，远远的在广场上就能看到，要去大雁塔要先进大慈恩寺，需要门票，然后进大雁塔有需要门票，可根据自己喜好选择是否进去。晚上我们去了吃了陕西特色菜馆“八百里秦川”，然后点了他们的特色“三秦九品”，但是我觉得一般，其实就是甜点，他家的菜品还挺好吃的，推荐！不夜城没什么特别的跨年活动，但是还是很热闹、人很多，当天旁边大悦城搞了跨年活动。<br><img src="/images/post/xi'an-5.jpg"></p>        <h2 id="day4-壶口瀑布"   >          <a href="#day4-壶口瀑布" class="heading-link"><i class="fas fa-link"></i></a><a href="#day4-壶口瀑布" class="headerlink" title="day4:壶口瀑布"></a>day4:壶口瀑布</h2>      <p>由于交通问题我们选择了报旅游团，因为太冷我们就没去华山选择了壶口瀑布，本来套餐里面还有包含其他地方的选择，但是我们只选了壶口瀑布，第一比较感兴趣，第二实在太累了😫。从西安到壶口坐车需要四个多小时，然后必须做景点的大巴车去到景点。其他没有什么特别的就是看看黄河，而且我们去的那个时候河面都结了很厚的一层冰。晚上我们去了导游推荐的“马蜂小炒炒泡馍”，挺好吃的😄。<br><img src="/images/post/xi'an-6.jpg"></p>        <h2 id="day5-白鹿原影视城-滑雪"   >          <a href="#day5-白鹿原影视城-滑雪" class="heading-link"><i class="fas fa-link"></i></a><a href="#day5-白鹿原影视城-滑雪" class="headerlink" title="day5:白鹿原影视城+滑雪"></a>day5:白鹿原影视城+滑雪</h2>      <p>这天原定是休息随便逛逛后出发去机场附近的酒店，后面我对象同事约了一起去滑雪，然后我们就11点多去了白鹿原滑雪场，开车到这边快一点了。平时这个滑雪场只要39，元旦涨到了88，三个小时，需要买保险10元，滑具押金需要300。这个滑雪场比较小，而且是人工雪，第一次滑雪，在平地上练习了一会然后鼓起勇气去斜坡滑，第一次摔了好几次，然后每次还自己起不来，需要有人扶起来，扶了几次之后才在三分之二的地方，然后就放弃了走下去的，后面又鼓起勇气去滑了几次，后面大概整个坡就只会摔一次，进步很大，也很累。四点结束后我们已经很饿了，附近也没什么特别好吃的吃饭的地方，最后选择了影视城门口的一个路边摊吃了特色活络面，不好吃，一股塑料味，不知道是不是因为餐具的问题。吃完然后就去逛影视城的（不需要门票），我们进去的时候天已经黑了，但是晚上貌似不关门我们八点多出来的时候还能进去。<br><img src="/images/post/xi'an-7.jpg"></p>        <h2 id="day6-返沪"   >          <a href="#day6-返沪" class="heading-link"><i class="fas fa-link"></i></a><a href="#day6-返沪" class="headerlink" title="day6:返沪"></a>day6:返沪</h2>      <p>最后一天就是返程回上海啦。因为咸阳机场离西安市区挺远的，我们定的酒店在机场附近石头村，我们当时挺晚的然后又觉得打车太贵了，然后我们就先做地铁坐到上林路站然后出来再打车，这就比较近比较便宜了。<br>整个旅行虽然很满很累，但是很开心，收获了很多，比较遗憾的是没有去看历史博物馆。西安真的不愧是十三朝古都，文化底蕴深厚，旅游团也比较规范，推荐👍👍</p>]]></content>
    
    
    <summary type="html">不入长安城，不知未央名。汉唐不尽是，芙蓉满园春。西安作为十三朝古都，中国七大古都之一，让我领略到了中国五千年的历史，给我留下了深刻的印象。西安鼓楼是现存中国最大鼓楼，位于西安城内西大街北院门南端，东与钟楼相望。西安它还有一个美丽的称呼“长安”。</summary>
    
    
    
    <category term="Live" scheme="http://example.com/categories/Live/"/>
    
    <category term="travel" scheme="http://example.com/categories/Live/travel/"/>
    
    
    <category term="记录生活" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    <category term="旅行" scheme="http://example.com/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>青海行</title>
    <link href="http://example.com/2020/09/08/qinghaiTraveling/"/>
    <id>http://example.com/2020/09/08/qinghaiTraveling/</id>
    <published>2020-09-08T14:54:36.000Z</published>
    <updated>2020-09-08T14:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年由于疫情原因一直呆在家里，还没出去过，如何公司同事组织了一个轻奢的hiking，由于各种原因在7月份才确定下来，然后7月份又是旺季，但是还好因为疫情人不多。（说明一下，我们因为人比较多15个人，找的是当地的俱乐部，全程有大巴跟车，有向导）。</p><p>为了节省时间，我们都买了的早上的飞机，这样可以确保中午能到西宁，下午还可以利用起来，不至于浪费一天的时间。中午到达后向导带我们去一个比较有特色的面馆简单吃了一点（ps：这边吃饭真的很实惠，不贵然后量也很多）。下午的行程是去门源花海。先到了一个观景台可以看远处的油菜花田，远处的景色也挺好看的，后面继续前进就可以路过了油菜花，我们就可以近距离欣赏花海了（ps：这边进油菜花田拍照是需要付费的，也不贵，五块十块的）。看完油菜花第一天的行程也结束了，晚上我们在祁连镇住宿、吃饭，为第二天去徒步做准备。晚上的饭的话我比较印象深的是那个牛肉汤，好像当地很多人一般吃饭就是一碗汤（里面有粉丝和牛肉）加个馍，当时我们的司机和领队就是这样吃的，然后可以尝试一下这边烤馍和酸奶，大盘鸡就是名副其实的大盘鸡很大一盘完全不像我们南方这边的大盘鸡，到这边当然要吃牛肉羊肉了。如果有时间到了祁连镇可以去逛逛瑞士印象街和卓尔山（ps：卓尔山是圣山，好像是不能登顶，我们由于行程比较满，没有时间去好好逛，只是路过看了一下）。<br><img src="/images/post/qinghai-7.jpeg"></p><p>第二天，上午的行程是去祁连山徒步，本来以为会是爬山，结果到了后大家完全不是在徒步，连领队都忍不住吐槽说我们不是在徒步，是来看风景拍照的。。。。大家边走边拍照，一上午才走一小段路，然后由于时间有限就没在继续往山里去了，准确的说我们真正的山里都还没进就结束徒步了😅。中午又回到了祁连县吃饭（有点后悔忘记拍照了，因为大家每次吃饭都是很饿的状态），这次菜印象较深的是一个土豆，是那种炸了的土豆片，这个菜以后我们每顿基本都点了。还有一个比较有本地特色的面炮仗面，其实我觉得一般。这里提一下我们发现这边的水果还是比较便宜的，我们后面买了很多水果以后每顿饭都自带水果，你自带酒水和水果这边店都不会说什么的。下午基本都是在车上度过的，下午的时候我也出现了高原反应，全程基本都在睡觉，头晕，呼吸也有点困难，不过还好下午没什么活动都是赶路。中途路过了至此行程的最高海拔—大垭口。晚上才到达我们的酒店，本来准备晚上篝火晚会的，结果下雨了就取消了，我们定的烤全羊也只有在室内吃了，很可惜，我们什么装备（投影仪、音响、吉他）什么都带了。<br><img src="/images/post/qinghai-2.jpeg"></p><p>第三天就是我们的骑行啦，开心😄。幸运的是睡一觉之后我的高反也好很多了，差点以为我们的骑行要延迟了，早上还有点小雨，但是雨很快就停了，我们的计划照常。我们从环湖西路鸟岛段开始骑行，骑至黑马河乡（大于40公里，但是我只骑了一半，太累了，屁股痛。。。）。公路是沿青海湖的，一路上风景特别漂亮，走走停停，还到湖边看见了湖里好多鱼，但是据说不能捉，超级多，感觉用手都能抓住。路上还遇到了有人朝拜，第一次见还是比较新奇的。在黑马河吃完午餐后坐车到江西沟（黑马河到江西沟这段路骑行俱乐部不提供保障，说是那段路不太好骑，来往车辆比较多，但是我们有的同伴还是选择要骑，很佩服）。在江西沟到南岸我们酒店还有一段路可以骑行，我前面放弃了一半想再继续骑，不然这趟旅行不太完美，这也是很不错的体验。<br><img src="/images/post/qinghai-3.jpeg"></p><p>第四天我们的目的地是沙漠，导游带我们去了片沙漠，到了之后还是挺失望的，那边就一小片沙漠，就是很外围，不能很好的体验真正的沙漠。我们在那小小的一品沙漠里还玩了沙漠摩托和滑滑梯，虽然沙漠小，但是总体还挺好玩。下午因为我们晚上是要在这边露营的，所以就要开始扎营搭帐篷，刚开始搭没多久就下雨了，雨太大了我们就先去大本营避雨，这边的雨来的快去得也快，雨停后我们继续搭建帐篷，这里又学会了一个技能–搭帐篷。晚上我们是请有家饭店到我们扎营的地方来烧烤，在沙漠中露营烧烤，然后点篝火，氛围不要不要的。而且在我们之后又有一波人也来到了这边露营，还免费观看了一场车技（他们开车冲上坡，而且还是在沙漠的地里）。<br><img src="/images/post/qinghai-4.jpeg"></p><p>第五天，我们早早的起床然后洗漱，昨天同一家饭店给我们送来了早餐，馍加汤。我以前没有在外面露营过，感觉还是挺不错的，很开心。吃完早饭我们就去湖边和沙漠逛逛了，湖滩都是沼泽，鞋都湿了，然后如果要去大沙漠那边要通过一个小河，然后大家只能脱鞋趟河过去，过去后才见识到真正的沙漠，一片无际，导游不让我们走太远，太危险了。由于行程安排，我们匆匆欣赏一下就回去了，之后就是返程和买特产了，😄😄<br><img src="/images/post/qinghai-5.jpeg"></p><p>最后总结一下这次旅行，这是一个很特别的体验，首先是第一次和同事和一大群不太熟悉的人一起出去旅行；然后不再是单纯的逛景点，而是去徒步和骑行，看风景，全程没去一个需要门票的景点；第三选择了旅行俱乐部，全程被安排好，有车，不用考虑路线和交通问题，很方便，并且是轻奢，一起自己出去都是相对比较经济实惠的旅行；最后是第一次去西北部，以前一直都是在南方这边游玩，风景真的相差很大，真的很美，很治愈，有机会一定要去西北部去看看。<br><img src="/images/post/qinghai-6.jpeg"></p>]]></content>
    
    
    <summary type="html">青海是新疆与西藏的融合，有“世界屋檐”的美称。其境内既有青海湖大海般的风光魅力，又有青藏高原的雄壮、河湟文化的辽阔。如今有机会去体验所以要将其记录下来，青海的风光也只能略览一二，有机会一定要去看看，青海、西藏都不错。</summary>
    
    
    
    <category term="Live" scheme="http://example.com/categories/Live/"/>
    
    <category term="travel" scheme="http://example.com/categories/Live/travel/"/>
    
    
    <category term="记录生活" scheme="http://example.com/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"/>
    
    <category term="旅行" scheme="http://example.com/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
</feed>

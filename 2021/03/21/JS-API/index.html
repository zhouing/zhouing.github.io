<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta name="description" content="主要是一些我常看到但不太熟熟悉的API，这里只是简单认识，未深入。">
<meta property="og:type" content="article">
<meta property="og:title" content="部分JS API理解">
<meta property="og:url" content="http://example.com/2021/03/21/JS-API/index.html">
<meta property="og:site_name" content="ZhouTing&#39;s Blog">
<meta property="og:description" content="主要是一些我常看到但不太熟熟悉的API，这里只是简单认识，未深入。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-21T03:06:29.000Z">
<meta property="article:modified_time" content="2021-03-21T03:06:29.000Z">
<meta property="article:author" content="Zhou Ting">
<meta property="article:tag" content="-前端 -javascript">
<meta name="twitter:card" content="summary"><title>部分JS API理解 | ZhouTing's Blog</title><link ref="canonical" href="http://example.com/2021/03/21/JS-API/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="ZhouTing's Blog" type="application/atom+xml">
</head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">ZhouTing's Blog</div><div class="header-banner-info__subtitle">一个回收自己生活的垃圾站。。。</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">部分JS API理解</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-03-21</span></span></div></header><div class="post-body">
        <h3 id="react兄弟组件通信"   >
          <a href="#react兄弟组件通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#react兄弟组件通信" class="headerlink" title="react兄弟组件通信"></a>react兄弟组件通信</h3>
      <p>1、找相同的父组件，既可以用props传递也可以使用context传递<br>2、使用全局机制实现通信，例redux<br>3、发布订阅模式</p>

        <h3 id="发布-订阅模式"   >
          <a href="#发布-订阅模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3>
      <p>组件间通信引入一个类的实例，并使用单例模式（只有一个实例）实现<br>定义发布对象</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class SingleonPush &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.listenList &#x3D; &#123;&#125;</span><br><span class="line">        this.instance &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    static getInstance: () &#x3D;&gt; &#123;</span><br><span class="line">        if (!this.instance) &#123;</span><br><span class="line">            this.instance &#x3D; new SingleonPush()</span><br><span class="line">        &#125;</span><br><span class="line">        return this.instance</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 订阅者添加订阅事件</span><br><span class="line">    addListen: (key, fn) &#x3D;&gt; &#123;</span><br><span class="line">        if(!this.listenList[key]) &#123;</span><br><span class="line">            this.listenList[key] &#x3D; []</span><br><span class="line">        &#125;</span><br><span class="line">        this.listensList[key].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 发布者发布消息，执行订阅者订阅的事件</span><br><span class="line">    trigger: () &#123;</span><br><span class="line">        const key &#x3D; Array.from(arguments).shift()</span><br><span class="line">        const fns &#x3D; this.listenList[key]</span><br><span class="line">        (fns || []).forEach(fn &#x3D;&gt; &#123;</span><br><span class="line">            fn.apply(this, arguments)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 移除订阅事件</span><br><span class="line">    removeListen: (key, fn) &#x3D;&gt; &#123;</span><br><span class="line">        const fns &#x3D; this.listenList[key]</span><br><span class="line">        if(!fns || fns?.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        if(!fn) &#123;</span><br><span class="line">            this.listenList[key] &#x3D; []</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fns.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">                if(item &#x3D;&#x3D;&#x3D; fn) &#123;</span><br><span class="line">                   fns.splice(index, 1) </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default SingleonPush.getInstance()</span><br></pre></td></tr></table></div></figure>
<p>订阅者订阅一个事件<br>订阅者：订阅一个或多个信道消息的对象</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import SingleonPush from &#39;..&#x2F;SingleonPush&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">SingleonPush.addlisten(&#39;back&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;订阅back&#39;)</span><br><span class="line">    SingleonPush.removeListen(&#39;back&#39;, handleExist)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>发布者发布一个back消息<br>发布者： 消息的发布者，往信道中投递消息的对象</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import SingleonPush from &#39;..&#x2F;SingleonPush&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">SingleonPush.trigger(&#39;back&#39;)</span><br></pre></td></tr></table></div></figure>

        <h3 id="IntersectionObserver"   >
          <a href="#IntersectionObserver" class="heading-link"><i class="fas fa-link"></i></a><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h3>
      <p>异步观察目标元素与其祖先元素或根元素交叉状态的方法（即观察目标元素是否可见）<br><code>const io = new IntersectionObserver(callback, option)</code><br>当元素可见比例超过指定阙值后，会调用callback，callback接收两个参数：<br>entries: 一个IntersectionObserverEntry对象的数组<br>observer: IntersectionObserver的实例<br>options配置选项：<br>root: 监听对象的祖先Element对象，默认为文档视口，<br>rootMargin： 一个在计算交叉值时添加至根的边界盒中的一组偏移量，值类似margin的值，默认没有margin<br>threshold： 规定了一个监听目标和边界盒交叉的比例值，可以是一个0.0-1.0的具体数字或数组，默认为0.0，意味着目标元素与边界的比例大于0.0时，目标元素被视为看见，如果设置为0.5则是在比例为50%的时候才视为看见，才会调用callback。<br>IntersectionObserverEntry对象属性：<br>time: 可见性发生变化的时间<br>target： 被观察的目标元素<br>rootBounds： 根元素的矩形区域信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null<br>boundingClientRect：目标元素的矩形区域的信息<br>intersectionRect：目标元素与视口（或根元素）的交叉区域的信息<br>intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0<br>isIntersecting: Boolean,如果为true，表示变换是从非交叉状态到交叉状态，反之为false</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现懒加载</span><br><span class="line">const oberver &#x3D; new IntersectionObserver((entries, ob) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(entries)</span><br><span class="line">    entries.forEach(ioEntry &#x3D;&gt; &#123;</span><br><span class="line">        const container &#x3D; ioEntry.target</span><br><span class="line">        const content &#x3D; container.querySelector(&#39;template&#39;).content</span><br><span class="line">        container.appendChild(content)</span><br><span class="line">        ob.unobserve(container)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">Array.from(document.querySelectorAll(&#39;lazy-load&#39;)).forEach(elm &#x3D;&gt; &#123;</span><br><span class="line">    observe.observe(elm)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>注： IntersectionObserver是异步的，实现采用了requestIdleCallback()，所以只有等线程空闲下来才会执行，优先级非常低</p>

        <h3 id="MutationObserver-监视DOM树所做的更改"   >
          <a href="#MutationObserver-监视DOM树所做的更改" class="heading-link"><i class="fas fa-link"></i></a><a href="#MutationObserver-监视DOM树所做的更改" class="headerlink" title="MutationObserver: 监视DOM树所做的更改"></a>MutationObserver: 监视DOM树所做的更改</h3>
      <p>属于微任务，异步的，为了防止Dom频繁变动占用js执行栈造成页面卡顿<br>会在DOM发生变化时被调用<br>实例方法：<br>disconnect(): 停止实例继续接收的通知<br>observer(): 通过回调函数开始接收通知<br>takeRecords(): 从通知队列中删除所有待处理的通知，并返回到MutationRecord对象的新Array中</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const dom &#x3D; document.getElementById(&#39;dom&#39;)</span><br><span class="line">const callback &#x3D; (mutationList, observe) &#x3D;&gt; &#123;</span><br><span class="line">    for(let mutation of mutationList) &#123;</span><br><span class="line">        &#x2F;&#x2F; mutation 为MutationRecord对象，MutationRecord对象是我们每修改一个就会在数组里面追加一个</span><br><span class="line">        if(mutation.type &#x3D;&#x3D;&#x3D; &#39;childList&#39;) &#123;</span><br><span class="line">            console.log(&#39;child node has changed&#39;)</span><br><span class="line">        &#125; else if (mutation.type &#x3D;&#x3D;&#x3D; &#39;attributes&#39;) &#123;</span><br><span class="line">            console.log(&#96;ths mutationAttributes name is $&#123;mutation.attributeName&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const observer &#x3D; new MutationObserver(callback)</span><br><span class="line">&#x2F;&#x2F; 调用observe()时,childList, attributes或characterData中至少有一个为true，否则会报错</span><br><span class="line">const config &#x3D; &#123;</span><br><span class="line">    attributes: true, &#x2F;&#x2F; 监听元素属性值得变更，如果为false，并且配置了attributeFilter或attributeOldValue为true，则会报错</span><br><span class="line">    childList: true, &#x2F;&#x2F; 设为true以监听目标节点（如果subtree为true，则包含子孙节点）添加或删除子节点，默认为false</span><br><span class="line">    subtree: true, &#x2F;&#x2F; 设为true以将监听范围扩展到目标节点下的所有节点</span><br><span class="line">    &#x2F;&#x2F; attributeFilter: Array, 指定要监视的属性名称，例如[&#39;calss&#39;, &#39;src&#39;]</span><br><span class="line">    &#x2F;&#x2F; attributeOldValue: Boolean, 当属性改动是，设置为true可以记录任何改动属性的上一个值</span><br><span class="line">    &#x2F;&#x2F; characterData: Boolean, 设为true以监听目标节点或子节点中包含的字符数据的变化, 如果为false，而characterDataOldValue为true，则会报错</span><br><span class="line">    &#x2F;&#x2F; characterDataOldValue: Boolean,设为true以在文本更改时记录节点文本的先前值</span><br><span class="line">&#125;</span><br><span class="line">observer.observer(dom, config)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; when it&#39;s time to stop observe</span><br><span class="line">&#x2F;&#x2F; handle any still-pending mutations</span><br><span class="line"></span><br><span class="line">const mutations &#x3D; observer.takeRecords() &#x2F;&#x2F; 同步的</span><br><span class="line">if(mutations) &#123;</span><br><span class="line">    callback(mutations)</span><br><span class="line">&#125;</span><br><span class="line">observer.disconnect()</span><br></pre></td></tr></table></div></figure>


        <h3 id="window-requestAnimationFrame-fn"   >
          <a href="#window-requestAnimationFrame-fn" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-requestAnimationFrame-fn" class="headerlink" title="window.requestAnimationFrame(fn)"></a>window.requestAnimationFrame(fn)</h3>
      <p>希望执行一个动画，并且要求浏览器在下一次重绘之前调用指定的回调函数更新动画<br>回调函数fn会在浏览器下一次重绘之前执行</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const animateBox &#x3D; document.getElementById(&#39;animate-box&#39;)</span><br><span class="line">const requestAnimationFrame &#x3D; window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;</span><br><span class="line">const cancelAnimationFrame &#x3D; window.cancelAnimationFrame || window.mozCancelAnimationFrame;</span><br><span class="line">let start</span><br><span class="line">let AnimationFrameID</span><br><span class="line">function step(timestamp) &#123;</span><br><span class="line">    &#x2F;&#x2F; timestamp为时间戳</span><br><span class="line">    if(start &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        start &#x3D; timestamp</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    const elapsed &#x3D; timestamp - start</span><br><span class="line">    animateBox.style.transform &#x3D; &#96;translateX($&#123;Math.min(0.1 * elapsed, 200)&#125;px)&#96;</span><br><span class="line">    if(elapsed &lt; 2000) &#123;</span><br><span class="line">        AnimationFrameID &#x3D; requestAnimationFrame(step)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cancelAnimationFrame(AnimationFrameID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AnimationFrameID &#x3D; requestAnimationFrame(step)</span><br></pre></td></tr></table></div></figure>

        <h3 id="window-requestIdleCallback-启用在浏览器空闲期对任务进行调度"   >
          <a href="#window-requestIdleCallback-启用在浏览器空闲期对任务进行调度" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-requestIdleCallback-启用在浏览器空闲期对任务进行调度" class="headerlink" title="window.requestIdleCallback(): 启用在浏览器空闲期对任务进行调度"></a>window.requestIdleCallback(): 启用在浏览器空闲期对任务进行调度</h3>
      <p><code>window.requestIdleCallback(callback[, options])</code><br>options: {timeout}<br>强烈建议使用timeout选项进行必要的工作，否则可能会在触发回调之前经过几秒钟</p>

        <h3 id="window-dispatchEvent-used-to-trigger-an-event"   >
          <a href="#window-dispatchEvent-used-to-trigger-an-event" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-dispatchEvent-used-to-trigger-an-event" class="headerlink" title="window.dispatchEvent(): used to trigger an event"></a>window.dispatchEvent(): used to trigger an event</h3>
      <p>向一个指定的事件目标派发一个事件</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; const event &#x3D; new Event(&#39;build&#39;)</span><br><span class="line">&#x2F;&#x2F; 如果需要添加数据可以使用CustomEvent()</span><br><span class="line">const event &#x3D; new CustomEvent(&#39;build&#39;, &#123; detail: &#39;this is detail&#39; &#125;)</span><br><span class="line"></span><br><span class="line">elm.addEventListener(&#39;build&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;This is detail: $&#123;e.detail&#125;&#96;)</span><br><span class="line">&#125;, false)</span><br><span class="line"></span><br><span class="line">elm.dispatchEvent(&#39;build&#39;)</span><br></pre></td></tr></table></div></figure>
<p>为了兼容性，可以使用旧的API</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const event &#x3D; document.createEvent(&#39;Event&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;event.initEvent(type, bubbles, cancelable);</span><br><span class="line">event.initEvent(&#39;build&#39;, true, true)</span><br><span class="line">elm.addEventListener(&#39;build&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(e.target)</span><br><span class="line">&#125;, false)</span><br><span class="line">elm.dispatchEvent(event)</span><br></pre></td></tr></table></div></figure>
<p><code>cancelled = !target.dispatchEvent(event)</code><br>返回值：如果该事件是可取消的且至少一个该事件的事件处理方法调用了<code>Event.preventDefault()</code>,则返回<code>false</code>，反之返回<code>true</code><br>注：与浏览器原生事件不同，原生事件是由DOM派发，并通过<code>event loop</code>异步调用事件处理函数；<code>dispatchEvent()</code>是同步调用事件处理程序</p>

        <h3 id="window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）"   >
          <a href="#window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-setImmediate-在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）" class="headerlink" title="window.setImmediate(): 在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）"></a>window.setImmediate(): 在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）</h3>
      <p>可以用setTimeout(fn, 0)替代</p>

        <h3 id="MessageChannel"   >
          <a href="#MessageChannel" class="heading-link"><i class="fas fa-link"></i></a><a href="#MessageChannel" class="headerlink" title="MessageChannel()"></a>MessageChannel()</h3>
      <p>创建一个新的消息通道，并通过它的两个MessagePort属性传递消息，在Web Worker中可用<br><code>const channel = new MessageChannel()</code><br>channel实例有两个属性：port1， port2<br>两个端口可以让你从一个端口发生消息，并在消息到达后再另一个端口监听<br>MessagePort上的方法：<br>postMessage: 发送消息，会自动序列化并且是深拷贝<br><code>port.postMessage(message, [transferList])</code><br>message可以是任何基本类型<br>start：开始发送该端口的消息队列（只有当使用<code>EventTarget.addEventListener</code>的时候才需要调用，使用<code>onmessage</code>时是默认开始的）<br>close: 断开接口连接<br>事件回调：继承自EventTarget的事件回调<br>onmessage: 是一个EventListener，当类型为 message 的 MessageEvent 在该端口触发时，会调用<br>onmessageerror: 类型为 MessageError 的 MessageEvent 被触发时，会调用，这意味着，端口收到了一条无法被反序列化的消息<br>事件： message、messageerror</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const channel &#x3D; new MessageChannel()</span><br><span class="line">const output &#x3D; document.querySelector(&#39;.output&#39;)</span><br><span class="line">const iframe &#x3D; document.querySelector(&#39;iframe)</span><br><span class="line"></span><br><span class="line">iframe.addEventListener(&#39;load&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    channel.port1.onmessage &#x3D; (e) &#x3D;&gt; &#123;</span><br><span class="line">        output.innerHTML &#x3D; e.data</span><br><span class="line">    &#125;</span><br><span class="line">    iframe.contentWindow.postMessage(&#39;This is a message from home page&#39;, &#39;*&#39;, [channel.port2])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>
<p>使用MessageChannel实现对象深拷贝</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const DeepClone &#x3D; (obj) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用Promise是为了方便拿到数据，因为下面是异步的</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        const channel &#x3D; new MessageChannel()</span><br><span class="line">        channel.port2.onmessage &#x3D; (e) &#x3D;&gt; resolve(e)</span><br><span class="line">        channel.port1.postMessage(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const originObj &#x3D; &#123; id: 1, info: &#123; name: &#39;jack&#39;&#125;&#125;</span><br><span class="line">DeepClone(originObj).then(res &#x3D;&gt; &#123;</span><br><span class="line">    const obj1 &#x3D; res</span><br><span class="line">    obj1.info.name &#x3D; &#39;mark&#39;</span><br><span class="line">    console.log(obj1, originObj) &#x2F;&#x2F; originObj不会改变</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h3 id="window-postMessage-：可以安全地实现跨源通信"   >
          <a href="#window-postMessage-：可以安全地实现跨源通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#window-postMessage-：可以安全地实现跨源通信" class="headerlink" title="window.postMessage()：可以安全地实现跨源通信"></a>window.postMessage()：可以安全地实现跨源通信</h3>
      <p>一般两个不同的页面只有同源(同协议，同端口，同域)才能互通消息，而window.postMessage提供了一种受控机制来规避这个限制<br><code>otherWindow.postMessage(message, targetOrigin[, transferList])</code><br>messgage: 自动序列化，深拷贝<br>message中的属性：<br>    data：传递过来的对象<br>    origin：消息发送方窗口的origin<br>    source：对发送消息窗口对象的引用，可以在两个窗口直接建立双向通信<br>targetOrigin：用来指定那些窗口能接收到消息事件。值可以是字符串’<em>‘(无限制)或一个URL。注：如果不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点<br>transferList：是一串和message同时传递的Transferable对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权<br>注安全问题： 如果需要从其他网站接收message，要始终使用origin和source属性来验证发件人的身份；在发送message时，请始终指定精确的目标origin，而不是’</em>‘</p>

        <h3 id="FileReader-允许web应用程序异步读取存储在计算机上的文件的内容"   >
          <a href="#FileReader-允许web应用程序异步读取存储在计算机上的文件的内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#FileReader-允许web应用程序异步读取存储在计算机上的文件的内容" class="headerlink" title="FileReader: 允许web应用程序异步读取存储在计算机上的文件的内容"></a>FileReader: 允许web应用程序异步读取存储在计算机上的文件的内容</h3>
      <p>使用File或Blob对象指定读取的文件或数据；File对象可以来自：Input元素选择文件返回的FileList对象；拖放操作生成的DataTransfer对象；来自HTMLCanvasElement上执行mozGetAsFile()方法后返回的结果<br><code>const fileReader = new FileReader()</code><br>属性：<br>error： 读取文件时发生的错误<br>readyState： 0(还没加载任何数据) | 1(数据正在被加载) | 2(已完成全部数据读取请求)<br>result： 文件的内容，只有在读取操作完成后才有效，数据格式根据使用那个方法来启动读取操作决定<br>事件处理：<br>onabort：读取操作被中断时触发，readyState为2<br>onerror<br>onload： 读取操作完成时触发<br>onloadstart<br>onloadend<br>onprogress<br>注： 这些事件都可以通过addEventListener使用<br>方法：<br>abort： 中止读取操作<br>readAsArrayBuffer： 开始读取指定的Blob中的内容，完成后result中保存的将是读取文件的ArrayBuffer数据对象<br>readAsBinaryString: 非标准<br>readAsDataURL<br>readAsText</p>

        <h4 id="ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区"   >
          <a href="#ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayBuffer-用来表示通用的、固定长度的原始二进制数据缓冲区" class="headerlink" title="ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区"></a>ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区</h4>
      <p>是一个字节数组<br>不能直接操作ArrayBuffer的内容，需要通过类型数组对象(TypedArray)或DataView对象来操作<br><code>const buffer = new ArrayBuffer(length)</code><br>length不能大于Number.MAX_SAFE_INTEGER(2**53)或为负数<br>实例属性： byteLength<br>实例方法： slice()</p>

        <h5 id="TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图"   >
          <a href="#TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图" class="heading-link"><i class="fas fa-link"></i></a><a href="#TypedArray-描述了一个底层的二进制数据缓冲的一个类数组视图" class="headerlink" title="TypedArray: 描述了一个底层的二进制数据缓冲的一个类数组视图"></a>TypedArray: 描述了一个底层的二进制数据缓冲的一个类数组视图</h5>
      <p>所有TypedArray：<br>Int8Array(), Unit8Array(), Uint8ClampedArray(), Int16Array(), Unit16Array(), Int32Array(), Unit32Array(), Float32Array(), Float64Array()<br>参数：length | TypedArray | object | buffer [, byteOffset [, length]]</p>

        <h5 id="DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口"   >
          <a href="#DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#DataView：-一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口" class="headerlink" title="DataView： 一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口"></a>DataView： 一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口</h5>
      <p><code>const view = new DataView(buffer[, byteOffset, byteLength])</code><br>可以进行读写操作，例如： view.setInt8(), view.getInt8</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">Zhou Ting</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2021/03/21/JS-API/">http://example.com/2021/03/21/JS-API/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/%E5%89%8D%E7%AB%AF-javascript/">-前端 -javascript</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2021/01/07/xi'an/"><span class="paginator-prev__text">长安行</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.</span> <span class="toc-text">
          react兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">
          发布&#x2F;订阅模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntersectionObserver"><span class="toc-number">3.</span> <span class="toc-text">
          IntersectionObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MutationObserver-%E7%9B%91%E8%A7%86DOM%E6%A0%91%E6%89%80%E5%81%9A%E7%9A%84%E6%9B%B4%E6%94%B9"><span class="toc-number">4.</span> <span class="toc-text">
          MutationObserver: 监视DOM树所做的更改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-requestAnimationFrame-fn"><span class="toc-number">5.</span> <span class="toc-text">
          window.requestAnimationFrame(fn)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-requestIdleCallback-%E5%90%AF%E7%94%A8%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A9%BA%E9%97%B2%E6%9C%9F%E5%AF%B9%E4%BB%BB%E5%8A%A1%E8%BF%9B%E8%A1%8C%E8%B0%83%E5%BA%A6"><span class="toc-number">6.</span> <span class="toc-text">
          window.requestIdleCallback(): 启用在浏览器空闲期对任务进行调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-dispatchEvent-used-to-trigger-an-event"><span class="toc-number">7.</span> <span class="toc-text">
          window.dispatchEvent(): used to trigger an event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-setImmediate-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%8C%E6%88%90%E5%85%B6%E4%BB%96%E7%B9%81%E9%87%8D%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%88%E9%9D%9E%E6%A0%87%E5%87%86%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%94%9F%E4%BA%A7%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">
          window.setImmediate(): 在浏览器完成其他繁重的任务后执行一个函数（非标准，不要在生产中使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageChannel"><span class="toc-number">9.</span> <span class="toc-text">
          MessageChannel()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-postMessage-%EF%BC%9A%E5%8F%AF%E4%BB%A5%E5%AE%89%E5%85%A8%E5%9C%B0%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%BA%90%E9%80%9A%E4%BF%A1"><span class="toc-number">10.</span> <span class="toc-text">
          window.postMessage()：可以安全地实现跨源通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader-%E5%85%81%E8%AE%B8web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%82%E6%AD%A5%E8%AF%BB%E5%8F%96%E5%AD%98%E5%82%A8%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">11.</span> <span class="toc-text">
          FileReader: 允许web应用程序异步读取存储在计算机上的文件的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayBuffer-%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E9%80%9A%E7%94%A8%E7%9A%84%E3%80%81%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%8E%9F%E5%A7%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">11.1.</span> <span class="toc-text">
          ArrayBuffer: 用来表示通用的、固定长度的原始二进制数据缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TypedArray-%E6%8F%8F%E8%BF%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E7%9A%84%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%95%B0%E7%BB%84%E8%A7%86%E5%9B%BE"><span class="toc-number">11.1.1.</span> <span class="toc-text">
          TypedArray: 描述了一个底层的二进制数据缓冲的一个类数组视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataView%EF%BC%9A-%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6ArrayBuffer%E5%AF%B9%E8%B1%A1%E4%B8%AD%E8%AF%BB%E5%86%99%E5%A4%9A%E7%A7%8D%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%95%E5%B1%82%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.2.</span> <span class="toc-text">
          DataView： 一个可以从二进制ArrayBuffer对象中读写多种数值类型的底层接口</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">上帝喜欢你，所以考验你</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://segmentfault.com/" target="_blank" rel="noopener" data-popover="思否" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">sf</span></a><a class="sidebar-ov-social-item" href="https://weibo.com/" target="_blank" rel="noopener" data-popover="微博" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weibo"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Zhou Ting</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.1.1</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script></body></html>